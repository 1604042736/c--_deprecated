#!/usr/bin/env python3.8
# @generated by pegen from compiler.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

from Compiler.Types import *
from Compiler.ASTs import *

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: $ | compound_stmt $
        mark = self._mark()
        if (
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return Program ( body = None )
        self._reset(mark)
        if (
            (a := self.compound_stmt())
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return Program ( body = a )
        self._reset(mark)
        return None

    @memoize
    def compound_stmt(self) -> Optional[Any]:
        # compound_stmt: statement+ | &'}'
        # nullable=True
        mark = self._mark()
        if (
            (a := self._loop1_1())
        ):
            return Compound ( body = a )
        self._reset(mark)
        if (
            self.positive_lookahead(self.expect, '}')
        ):
            return Compound ( body = [] )
        self._reset(mark)
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: if_stmt | 'return' exp ';' | call ';' | funcdef | vardef ';' | exp_stmt | '{' compound_stmt '}'
        mark = self._mark()
        if (
            (if_stmt := self.if_stmt())
        ):
            return if_stmt
        self._reset(mark)
        if (
            (literal := self.expect('return'))
            and
            (a := self.exp())
            and
            (literal_1 := self.expect(';'))
        ):
            return Return ( exp = a )
        self._reset(mark)
        if (
            (a := self.call())
            and
            (literal := self.expect(';'))
        ):
            return a
        self._reset(mark)
        if (
            (funcdef := self.funcdef())
        ):
            return funcdef
        self._reset(mark)
        if (
            (a := self.vardef())
            and
            (literal := self.expect(';'))
        ):
            return a
        self._reset(mark)
        if (
            (exp_stmt := self.exp_stmt())
        ):
            return exp_stmt
        self._reset(mark)
        if (
            (literal := self.expect('{'))
            and
            (a := self.compound_stmt())
            and
            (literal_1 := self.expect('}'))
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def if_stmt(self) -> Optional[Any]:
        # if_stmt: 'if' exp statement 'else' statement | 'if' exp statement
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (a := self.exp())
            and
            (b := self.statement())
            and
            (literal_1 := self.expect('else'))
            and
            (c := self.statement())
        ):
            return If ( exp = a , body = b , orelse = c )
        self._reset(mark)
        if (
            (literal := self.expect('if'))
            and
            (a := self.exp())
            and
            (b := self.statement())
        ):
            return If ( exp = a , body = b , orelse = None )
        self._reset(mark)
        return None

    @memoize
    def exp_stmt(self) -> Optional[Any]:
        # exp_stmt: exp ';'
        mark = self._mark()
        if (
            (a := self.exp())
            and
            (literal := self.expect(';'))
        ):
            return ExpStmt ( exp = a )
        self._reset(mark)
        return None

    @memoize
    def exp(self) -> Optional[Any]:
        # exp: or_exp
        mark = self._mark()
        if (
            (or_exp := self.or_exp())
        ):
            return or_exp
        self._reset(mark)
        return None

    @memoize
    def or_exp(self) -> Optional[Any]:
        # or_exp: and_exp (('or' and_exp))+ | and_exp
        mark = self._mark()
        if (
            (a := self.and_exp())
            and
            (b := self._loop1_2())
        ):
            return BoolOp ( op = Or ( ) , values = [a] + [i [1] for i in b] )
        self._reset(mark)
        if (
            (and_exp := self.and_exp())
        ):
            return and_exp
        self._reset(mark)
        return None

    @memoize
    def and_exp(self) -> Optional[Any]:
        # and_exp: assign (('and' assign))+ | assign
        mark = self._mark()
        if (
            (a := self.assign())
            and
            (b := self._loop1_3())
        ):
            return BoolOp ( op = And ( ) , values = [a] + [i [1] for i in b] )
        self._reset(mark)
        if (
            (assign := self.assign())
        ):
            return assign
        self._reset(mark)
        return None

    @memoize
    def assign(self) -> Optional[Any]:
        # assign: assign_exp '=' exp | bitor_exp
        mark = self._mark()
        if (
            (a := self.assign_exp())
            and
            (literal := self.expect('='))
            and
            (b := self.exp())
        ):
            return Assign ( targets = [a] , value = b )
        self._reset(mark)
        if (
            (bitor_exp := self.bitor_exp())
        ):
            return bitor_exp
        self._reset(mark)
        return None

    @memoize
    def assign_exp(self) -> Optional[Any]:
        # assign_exp: '*'+ assign_exp | t_primary '[' exp ']' !t_lookahead | t_primary '.' NAME !t_lookahead | call !t_lookahead | NAME
        mark = self._mark()
        if (
            (a := self._loop1_4())
            and
            (b := self.assign_exp())
        ):
            return UnpackRef ( exp = b , level = len ( a ) )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.exp())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return Subscript ( value = a , slice = b , mode = Store ( ) )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return Attribute ( value = a , attr = b . string , mode = Store ( ) )
        self._reset(mark)
        if (
            (call := self.call())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return call
        self._reset(mark)
        if (
            (a := self.name())
        ):
            return Name ( id = a . string , mode = Store ( ) )
        self._reset(mark)
        return None

    @memoize_left_rec
    def t_primary(self) -> Optional[Any]:
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' exp ']' &t_lookahead | NAME &t_lookahead
        mark = self._mark()
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Attribute ( value = a , attr = b . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.exp())
            and
            (literal_1 := self.expect(']'))
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Subscript ( value = a , slice = b , mode = Load ( ) )
        self._reset(mark)
        if (
            (a := self.name())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Name ( id = a . string , mode = Load ( ) )
        self._reset(mark)
        return None

    @memoize
    def t_lookahead(self) -> Optional[Any]:
        # t_lookahead: '(' | '[' | '.'
        mark = self._mark()
        if (
            (literal := self.expect('('))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('['))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('.'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitor_exp(self) -> Optional[Any]:
        # bitor_exp: bitor_exp '|' bitxor_exp | bitxor_exp
        mark = self._mark()
        if (
            (a := self.bitor_exp())
            and
            (literal := self.expect('|'))
            and
            (b := self.bitxor_exp())
        ):
            return BinOp ( left = a , op = BitOr ( ) , right = b )
        self._reset(mark)
        if (
            (bitxor_exp := self.bitxor_exp())
        ):
            return bitxor_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitxor_exp(self) -> Optional[Any]:
        # bitxor_exp: bitxor_exp '^' bitand_exp | bitand_exp
        mark = self._mark()
        if (
            (a := self.bitxor_exp())
            and
            (literal := self.expect('^'))
            and
            (b := self.bitand_exp())
        ):
            return BinOp ( left = a , op = BitXor ( ) , right = b )
        self._reset(mark)
        if (
            (bitand_exp := self.bitand_exp())
        ):
            return bitand_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitand_exp(self) -> Optional[Any]:
        # bitand_exp: bitand_exp '&' compare_exp | compare_exp
        mark = self._mark()
        if (
            (a := self.bitand_exp())
            and
            (literal := self.expect('&'))
            and
            (b := self.compare_exp())
        ):
            return BinOp ( left = a , op = BitAnd ( ) , right = b )
        self._reset(mark)
        if (
            (compare_exp := self.compare_exp())
        ):
            return compare_exp
        self._reset(mark)
        return None

    @memoize
    def compare_exp(self) -> Optional[Any]:
        # compare_exp: shift_exp compares | shift_exp
        mark = self._mark()
        if (
            (a := self.shift_exp())
            and
            (b := self.compares())
        ):
            return Compare ( left = a , ops = [i for i , j in b] , values = [j for i , j in b] )
        self._reset(mark)
        if (
            (shift_exp := self.shift_exp())
        ):
            return shift_exp
        self._reset(mark)
        return None

    @memoize
    def compares(self) -> Optional[Any]:
        # compares: compare+
        mark = self._mark()
        if (
            (_loop1_5 := self._loop1_5())
        ):
            return _loop1_5
        self._reset(mark)
        return None

    @memoize
    def compare(self) -> Optional[Any]:
        # compare: '<' shift_exp | '<=' shift_exp | '>' shift_exp | '>=' shift_exp | '==' shift_exp | '!=' shift_exp
        mark = self._mark()
        if (
            (literal := self.expect('<'))
            and
            (a := self.shift_exp())
        ):
            return ( Lt ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('<='))
            and
            (a := self.shift_exp())
        ):
            return ( Leq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('>'))
            and
            (a := self.shift_exp())
        ):
            return ( Gt ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('>='))
            and
            (a := self.shift_exp())
        ):
            return ( Geq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('=='))
            and
            (a := self.shift_exp())
        ):
            return ( Eq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('!='))
            and
            (a := self.shift_exp())
        ):
            return ( Neq ( ) , a )
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_exp(self) -> Optional[Any]:
        # shift_exp: shift_exp '<<' add_exp | shift_exp '>>' add_exp | add_exp
        mark = self._mark()
        if (
            (a := self.shift_exp())
            and
            (literal := self.expect('<<'))
            and
            (b := self.add_exp())
        ):
            return BinOp ( left = a , op = RShift ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.shift_exp())
            and
            (literal := self.expect('>>'))
            and
            (b := self.add_exp())
        ):
            return BinOp ( left = a , op = LShift ( ) , right = b )
        self._reset(mark)
        if (
            (add_exp := self.add_exp())
        ):
            return add_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def add_exp(self) -> Optional[Any]:
        # add_exp: add_exp '+' mul_exp | add_exp '-' mul_exp | mul_exp
        mark = self._mark()
        if (
            (a := self.add_exp())
            and
            (literal := self.expect('+'))
            and
            (b := self.mul_exp())
        ):
            return BinOp ( left = a , op = Add ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.add_exp())
            and
            (literal := self.expect('-'))
            and
            (b := self.mul_exp())
        ):
            return BinOp ( left = a , op = Sub ( ) , right = b )
        self._reset(mark)
        if (
            (mul_exp := self.mul_exp())
        ):
            return mul_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def mul_exp(self) -> Optional[Any]:
        # mul_exp: mul_exp '*' prefix_exp | mul_exp '/' prefix_exp | mul_exp '%' prefix_exp | prefix_exp
        mark = self._mark()
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('*'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Mul ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('/'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Div ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('%'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Mod ( ) , right = b )
        self._reset(mark)
        if (
            (prefix_exp := self.prefix_exp())
        ):
            return prefix_exp
        self._reset(mark)
        return None

    @memoize
    def prefix_exp(self) -> Optional[Any]:
        # prefix_exp: '&' postfix_exp | '*'+ postfix_exp | postfix_exp
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (literal := self.expect('&'))
            and
            (a := self.postfix_exp())
        ):
            return Address ( exp = a )
        self._reset(mark)
        if (
            (a := self._loop1_6())
            and
            (b := self.postfix_exp())
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return UnpackRef ( exp = b , level = len ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (postfix_exp := self.postfix_exp())
        ):
            return postfix_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def postfix_exp(self) -> Optional[Any]:
        # postfix_exp: postfix_exp '[' exp ']' | call | postfix_exp '.' NAME | primary_exp
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (a := self.postfix_exp())
            and
            (literal := self.expect('['))
            and
            (b := self.exp())
            and
            (literal_1 := self.expect(']'))
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return Subscript ( value = a , slice = b , mode = Load ( ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (call := self.call())
        ):
            return call
        self._reset(mark)
        if (
            (a := self.postfix_exp())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
        ):
            return Attribute ( value = a , attr = b . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (primary_exp := self.primary_exp())
        ):
            return primary_exp
        self._reset(mark)
        return None

    @memoize
    def call(self) -> Optional[Any]:
        # call: NAME '(' arg_exp_list? ')'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (a := self.name())
            and
            (literal := self.expect('('))
            and
            (b := self.arg_exp_list(),)
            and
            (literal_1 := self.expect(')'))
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return Call ( func = a . string , args = b if b else [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @memoize
    def arg_exp_list(self) -> Optional[Any]:
        # arg_exp_list: exp arg_exp_more*
        mark = self._mark()
        if (
            (a := self.exp())
            and
            (b := self._loop0_7(),)
        ):
            return [a] + b if b else [a]
        self._reset(mark)
        return None

    @memoize
    def arg_exp_more(self) -> Optional[Any]:
        # arg_exp_more: ',' exp
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (a := self.exp())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def primary_exp(self) -> Optional[Any]:
        # primary_exp: NAME | STRING | NUMBER | '(' exp ')'
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return Name ( id = name . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (string := self.string())
        ):
            return String ( str = string . string [1 : - 1] )
        self._reset(mark)
        if (
            (number := self.number())
        ):
            return Num ( num = number . string )
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (a := self.exp())
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def atom_type(self) -> Optional[Any]:
        # atom_type: 'int'
        mark = self._mark()
        if (
            (literal := self.expect('int'))
        ):
            return Int ( )
        self._reset(mark)
        return None

    @memoize
    def pointer_type(self) -> Optional[Any]:
        # pointer_type: atom_type '*'+
        mark = self._mark()
        if (
            (a := self.atom_type())
            and
            (b := self._loop1_8())
        ):
            return Pointer ( base_type = a , level = len ( b ) )
        self._reset(mark)
        return None

    @memoize
    def array_type(self) -> Optional[Any]:
        # array_type: atom_type (('[' NUMBER ']'))+
        mark = self._mark()
        if (
            (a := self.atom_type())
            and
            (b := self._loop1_9())
        ):
            return Array ( base_type = a , dim = [i [1] for i in b] )
        self._reset(mark)
        return None

    @memoize
    def type(self) -> Optional[Any]:
        # type: array_type | pointer_type | atom_type
        mark = self._mark()
        if (
            (array_type := self.array_type())
        ):
            return array_type
        self._reset(mark)
        if (
            (pointer_type := self.pointer_type())
        ):
            return pointer_type
        self._reset(mark)
        if (
            (atom_type := self.atom_type())
        ):
            return atom_type
        self._reset(mark)
        return None

    @memoize
    def vardef(self) -> Optional[Any]:
        # vardef: type vardef_list
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.vardef_list())
        ):
            return VarDef ( type = a , vars = b [0] , defaults = b [1] )
        self._reset(mark)
        return None

    @memoize
    def vardef_atom(self) -> Optional[Any]:
        # vardef_atom: NAME '=' exp | NAME
        mark = self._mark()
        if (
            (a := self.name())
            and
            (literal := self.expect('='))
            and
            (b := self.exp())
        ):
            return ( a . string , b )
        self._reset(mark)
        if (
            (a := self.name())
        ):
            return ( a . string , None )
        self._reset(mark)
        return None

    @memoize
    def vardef_list(self) -> Optional[Any]:
        # vardef_list: vardef_atom ((',' vardef_atom))*
        mark = self._mark()
        if (
            (a := self.vardef_atom())
            and
            (b := self._loop0_10(),)
        ):
            return ( [a [0]] + [i [1] [0] for i in b] , [a [1]] + [i [1] [1] for i in b] )
        self._reset(mark)
        return None

    @memoize
    def funcdef(self) -> Optional[Any]:
        # funcdef: type NAME '(' arg_def_list? ')' statement | type NAME '(' arg_def_list? ')'
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (literal := self.expect('('))
            and
            (c := self.arg_def_list(),)
            and
            (literal_1 := self.expect(')'))
            and
            (d := self.statement())
        ):
            return FuncDef ( return_type = a , name = b . string , args = c if c else [] , body = d )
        self._reset(mark)
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (literal := self.expect('('))
            and
            (c := self.arg_def_list(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return FuncDef ( return_type = a , name = b . string , args = c if c else [] )
        self._reset(mark)
        return None

    @memoize
    def arg_def_list(self) -> Optional[Any]:
        # arg_def_list: vardef arg_def_more*
        mark = self._mark()
        if (
            (a := self.vardef())
            and
            (b := self._loop0_11(),)
        ):
            return [a] + b if b else [a]
        self._reset(mark)
        return None

    @memoize
    def arg_def_more(self) -> Optional[Any]:
        # arg_def_more: ',' vardef
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (a := self.vardef())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def _loop1_1(self) -> Optional[Any]:
        # _loop1_1: statement
        mark = self._mark()
        children = []
        while (
            (statement := self.statement())
        ):
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_2(self) -> Optional[Any]:
        # _loop1_2: ('or' and_exp)
        mark = self._mark()
        children = []
        while (
            (_tmp_12 := self._tmp_12())
        ):
            children.append(_tmp_12)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_3(self) -> Optional[Any]:
        # _loop1_3: ('and' assign)
        mark = self._mark()
        children = []
        while (
            (_tmp_13 := self._tmp_13())
        ):
            children.append(_tmp_13)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_4(self) -> Optional[Any]:
        # _loop1_4: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_5(self) -> Optional[Any]:
        # _loop1_5: compare
        mark = self._mark()
        children = []
        while (
            (compare := self.compare())
        ):
            children.append(compare)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_6(self) -> Optional[Any]:
        # _loop1_6: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_7(self) -> Optional[Any]:
        # _loop0_7: arg_exp_more
        mark = self._mark()
        children = []
        while (
            (arg_exp_more := self.arg_exp_more())
        ):
            children.append(arg_exp_more)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_8(self) -> Optional[Any]:
        # _loop1_8: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_9(self) -> Optional[Any]:
        # _loop1_9: ('[' NUMBER ']')
        mark = self._mark()
        children = []
        while (
            (_tmp_14 := self._tmp_14())
        ):
            children.append(_tmp_14)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: (',' vardef_atom)
        mark = self._mark()
        children = []
        while (
            (_tmp_15 := self._tmp_15())
        ):
            children.append(_tmp_15)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_11(self) -> Optional[Any]:
        # _loop0_11: arg_def_more
        mark = self._mark()
        children = []
        while (
            (arg_def_more := self.arg_def_more())
        ):
            children.append(arg_def_more)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_12(self) -> Optional[Any]:
        # _tmp_12: 'or' and_exp
        mark = self._mark()
        if (
            (literal := self.expect('or'))
            and
            (and_exp := self.and_exp())
        ):
            return [literal, and_exp]
        self._reset(mark)
        return None

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: 'and' assign
        mark = self._mark()
        if (
            (literal := self.expect('and'))
            and
            (assign := self.assign())
        ):
            return [literal, assign]
        self._reset(mark)
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: '[' NUMBER ']'
        mark = self._mark()
        if (
            (literal := self.expect('['))
            and
            (number := self.number())
            and
            (literal_1 := self.expect(']'))
        ):
            return [literal, number, literal_1]
        self._reset(mark)
        return None

    @memoize
    def _tmp_15(self) -> Optional[Any]:
        # _tmp_15: ',' vardef_atom
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (vardef_atom := self.vardef_atom())
        ):
            return [literal, vardef_atom]
        self._reset(mark)
        return None

    KEYWORDS = ('else', 'or', 'and', 'if', 'int', 'return')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
