# 简介
`c--3-py`是使用python编写的一款编程语言,它与`c--0.x``c--1.x``c--2.x`不同的是,它采用了别的运行方式,虽然没什么用而且会使它更慢
# 语法
与python语法类似
# 特性
由于运行机制的特殊,`c--3`可以完成许多别的编程语言无法做到的事情
```
try:
    if a
        a=1
except:
    print('Exception')
```
这段代码的2-3行有语法错误，像python这样的语言会抛出该错误而无视`try-except`语句，但`c--3`会捕捉这样的语法错误，因此这段代码最终会执行第5行的内容
- 注意，我并没有加入对语法错误时的恢复处理，因此一个语法错误可能会导致一连串的语法错误，甚至会导致`try-except`语句无法正常解析
# 运行机制
## 概况
`c--3`运行的时侯通过语法分析得到语法树后,就开始运行,不生成字节码,以语法树作为字节码运行。可以看成将原先生成字节码的步骤改成了直接运行
## 词法分析
`c--3`的词法分析无太大差别，唯一不同的是它多了`startlineno`和`endlineno`两个变量，这两个变量指的是词法分析时代码的解析的起始位置和终止位置，具体原因会在[后面](####`Unkown`语法树)讲到
## 语法分析
由于特殊需要，`c--3`的语法分析并没有使用`pegen`生成，而是手动编写，语法跟`python`差不多
### 语法树
在`c--3.0`中，语法树似乎发挥了很大的作用
#### 分类
主要分为两类`Sentence`和`Expr`,两者的主要区别在于前者的`runcount`默认为-2，后者默认为0，`Sentence`解析好后会运行而`Expr`不会，原因如下
```
a=1
```
对于这行代码,`a`会生成`Name`语法树，它的`mode`被设置为`load`，但我们期望它是`store`，如果此时运行会造成错误
#### `haverun`装饰器
每个语法树拥有一个`runcount`属性，对于语句(`Sentence`)来说，它的默认值是-2，该装饰器在语法树运行前进行检查，如果`runcount`为-1，就说明它已经运行过，就不再运行，下面举个例子
```
if a:
    a=1
```
1. 第一行会生成`If`语法树，然后该语法树会对`if`代码块的内容进行解析生成语法树，在解析时会发生(2)的动作，然后运行解析获得的语法树，即(2)中的`Assign`语法树
2. 第二行的`a=1`在生成`Assign`之后会直接运行，此时该语法树的`runcount`由-2变为-1
由此可见,在(1)执行后后，(2)中的语法树运行了2次，所以为了避免重复运行，在`runcount`为-1时不运行
#### `Unkown`语法树
在遇到某些语句比如`if`,`while`,`def`时，我们会跳过相应的代码块，并用`Unkown`语法树代替。它保存了代码块的信息，在执行的时侯会根据这些信息，回到原来的位置解析，此时`Lexer`的`startlineno`和`endlineno`就发挥了用处
#### `break`,`contiune`,`return`
由于特殊的机制，这些跳转动作抛出对应的异常来达到目标
`BreadException`和`ContinueException`可以被`while`语句捕捉，并据此执行相应的操作
`ReturnException`可以被`SyntaxTree.call`捕捉
如果它们不在他们该在的位置，这些异常将会被`_compile`捕捉并输出错误信息