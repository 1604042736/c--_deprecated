#!/usr/bin/env python3.8
# @generated by pegen from Grammar\compiler.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser

from SyntaxTrees import *

def get_var_def_list(a,b,c):
    result={'names':[a],'values':[b if b else None]}
    if c:
        for i in c:
            result['names'].append(i[0])
            result['values'].append(i[1])
    return result

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Any]:
        # start: sentences? $
        mark = self._mark()
        if (
            (a := self.sentences(),)
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return Program ( body = a if a else [] )
        self._reset(mark)
        return None

    @memoize
    def body(self) -> Optional[Any]:
        # body: NEWLINE INDENT sentences DEDENT
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (_indent := self.expect('INDENT'))
            and
            (a := self.sentences())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def sentences(self) -> Optional[Any]:
        # sentences: sentence*
        # nullable=True
        mark = self._mark()
        if (
            (_loop0_1 := self._loop0_1(),)
        ):
            return _loop0_1
        self._reset(mark)
        return None

    @memoize
    def sentence(self) -> Optional[Any]:
        # sentence: statement NEWLINE | statement
        mark = self._mark()
        if (
            (a := self.statement())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return a
        self._reset(mark)
        if (
            (statement := self.statement())
        ):
            return statement
        self._reset(mark)
        return None

    @memoize
    def statement(self) -> Optional[Any]:
        # statement: &'if' if_sentence | &'while' while_sentence | &'return' return_sentence | &'extern' extern_sentence | 'pass' | function | call | assign | define
        mark = self._mark()
        if (
            self.positive_lookahead(self.expect, 'if')
            and
            (if_sentence := self.if_sentence())
        ):
            return if_sentence
        self._reset(mark)
        if (
            self.positive_lookahead(self.expect, 'while')
            and
            (while_sentence := self.while_sentence())
        ):
            return while_sentence
        self._reset(mark)
        if (
            self.positive_lookahead(self.expect, 'return')
            and
            (return_sentence := self.return_sentence())
        ):
            return return_sentence
        self._reset(mark)
        if (
            self.positive_lookahead(self.expect, 'extern')
            and
            (extern_sentence := self.extern_sentence())
        ):
            return extern_sentence
        self._reset(mark)
        if (
            (literal := self.expect('pass'))
        ):
            return Pass ( )
        self._reset(mark)
        if (
            (function := self.function())
        ):
            return function
        self._reset(mark)
        if (
            (call := self.call())
        ):
            return call
        self._reset(mark)
        if (
            (assign := self.assign())
        ):
            return assign
        self._reset(mark)
        if (
            (define := self.define())
        ):
            return define
        self._reset(mark)
        return None

    @memoize
    def defs(self) -> Optional[Any]:
        # defs: struct_def | function_def | var_def
        mark = self._mark()
        if (
            (struct_def := self.struct_def())
        ):
            return struct_def
        self._reset(mark)
        if (
            (function_def := self.function_def())
        ):
            return function_def
        self._reset(mark)
        if (
            (var_def := self.var_def())
        ):
            return var_def
        self._reset(mark)
        return None

    @memoize
    def define(self) -> Optional[Any]:
        # define: defs NEWLINE | defs
        mark = self._mark()
        if (
            (a := self.defs())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return a
        self._reset(mark)
        if (
            (defs := self.defs())
        ):
            return defs
        self._reset(mark)
        return None

    @memoize
    def defines(self) -> Optional[Any]:
        # defines: define+
        mark = self._mark()
        if (
            (_loop1_2 := self._loop1_2())
        ):
            return _loop1_2
        self._reset(mark)
        return None

    @memoize
    def def_list(self) -> Optional[Any]:
        # def_list: NEWLINE INDENT defines DEDENT
        mark = self._mark()
        if (
            (_newline := self.expect('NEWLINE'))
            and
            (_indent := self.expect('INDENT'))
            and
            (a := self.defines())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def extern_sentence(self) -> Optional[Any]:
        # extern_sentence: 'extern' ':' def_list | 'extern' define
        mark = self._mark()
        if (
            (literal := self.expect('extern'))
            and
            (literal_1 := self.expect(':'))
            and
            (a := self.def_list())
        ):
            return Extern ( extern = a )
        self._reset(mark)
        if (
            (literal := self.expect('extern'))
            and
            (a := self.define())
        ):
            return Extern ( extern = [a] )
        self._reset(mark)
        return None

    @memoize
    def return_sentence(self) -> Optional[Any]:
        # return_sentence: 'return' expression
        mark = self._mark()
        if (
            (literal := self.expect('return'))
            and
            (a := self.expression())
        ):
            return Return ( value = a )
        self._reset(mark)
        return None

    @memoize
    def while_sentence(self) -> Optional[Any]:
        # while_sentence: 'while' expression ':' body
        mark = self._mark()
        if (
            (literal := self.expect('while'))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.body())
        ):
            return While ( exp = a , body = b )
        self._reset(mark)
        return None

    @memoize
    def function(self) -> Optional[Any]:
        # function: type NAME '(' arg_def_list? ')' ':' body | function_def
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (literal := self.expect('('))
            and
            (c := self.arg_def_list(),)
            and
            (literal_1 := self.expect(')'))
            and
            (literal_2 := self.expect(':'))
            and
            (d := self.body())
        ):
            return Function ( type = a , name = b . string , args = c if c else [] , body = d )
        self._reset(mark)
        if (
            (function_def := self.function_def())
        ):
            return function_def
        self._reset(mark)
        return None

    @memoize
    def function_def(self) -> Optional[Any]:
        # function_def: type NAME '(' arg_def_list? ')'
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (literal := self.expect('('))
            and
            (c := self.arg_def_list(),)
            and
            (literal_1 := self.expect(')'))
        ):
            return Function ( type = a , name = b . string , args = c if c else [] )
        self._reset(mark)
        return None

    @memoize
    def if_sentence(self) -> Optional[Any]:
        # if_sentence: 'if' expression ':' body elif_sentence?
        mark = self._mark()
        if (
            (literal := self.expect('if'))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.body())
            and
            (c := self.elif_sentence(),)
        ):
            return If ( exp = a , body = b , orelse = c )
        self._reset(mark)
        return None

    @memoize
    def elif_sentence(self) -> Optional[Any]:
        # elif_sentence: 'elif' expression ':' body elif_sentence? | else_sentence
        mark = self._mark()
        if (
            (literal := self.expect('elif'))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.body())
            and
            (c := self.elif_sentence(),)
        ):
            return If ( exp = a , body = b , orelse = c )
        self._reset(mark)
        if (
            (else_sentence := self.else_sentence())
        ):
            return else_sentence
        self._reset(mark)
        return None

    @memoize
    def else_sentence(self) -> Optional[Any]:
        # else_sentence: 'else' ':' body
        mark = self._mark()
        if (
            (literal := self.expect('else'))
            and
            (literal_1 := self.expect(':'))
            and
            (a := self.body())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def basic_type(self) -> Optional[Any]:
        # basic_type: 'int' | 'void' | 'char'
        mark = self._mark()
        if (
            (literal := self.expect('int'))
        ):
            return Int ( )
        self._reset(mark)
        if (
            (literal := self.expect('void'))
        ):
            return Void ( )
        self._reset(mark)
        if (
            (literal := self.expect('char'))
        ):
            return Char ( )
        self._reset(mark)
        return None

    @memoize
    def pointer_type(self) -> Optional[Any]:
        # pointer_type: single_type '*'+
        mark = self._mark()
        if (
            (a := self.single_type())
            and
            (b := self._loop1_3())
        ):
            return Pointer ( type = a , level = len ( b ) )
        self._reset(mark)
        return None

    @memoize
    def single_type(self) -> Optional[Any]:
        # single_type: basic_type | struct_type
        mark = self._mark()
        if (
            (basic_type := self.basic_type())
        ):
            return basic_type
        self._reset(mark)
        if (
            (struct_type := self.struct_type())
        ):
            return struct_type
        self._reset(mark)
        return None

    @memoize
    def mult_type(self) -> Optional[Any]:
        # mult_type: pointer_type | single_type
        mark = self._mark()
        if (
            (pointer_type := self.pointer_type())
        ):
            return pointer_type
        self._reset(mark)
        if (
            (single_type := self.single_type())
        ):
            return single_type
        self._reset(mark)
        return None

    @memoize
    def array_type(self) -> Optional[Any]:
        # array_type: mult_type array_dimen+
        mark = self._mark()
        if (
            (a := self.mult_type())
            and
            (b := self._loop1_4())
        ):
            return Array ( type = a , dimen = b )
        self._reset(mark)
        return None

    @memoize
    def array_dimen(self) -> Optional[Any]:
        # array_dimen: '[' NUMBER ']'
        mark = self._mark()
        if (
            (literal := self.expect('['))
            and
            (a := self.number())
            and
            (literal_1 := self.expect(']'))
        ):
            return a . string
        self._reset(mark)
        return None

    @memoize
    def struct_type(self) -> Optional[Any]:
        # struct_type: 'struct' NAME
        mark = self._mark()
        if (
            (literal := self.expect('struct'))
            and
            (a := self.name())
        ):
            return Struct ( name = a . string )
        self._reset(mark)
        return None

    @memoize
    def type(self) -> Optional[Any]:
        # type: array_type | mult_type
        mark = self._mark()
        if (
            (array_type := self.array_type())
        ):
            return array_type
        self._reset(mark)
        if (
            (mult_type := self.mult_type())
        ):
            return mult_type
        self._reset(mark)
        return None

    @memoize
    def struct_def(self) -> Optional[Any]:
        # struct_def: 'struct' NAME ':' body
        mark = self._mark()
        if (
            (literal := self.expect('struct'))
            and
            (a := self.name())
            and
            (literal_1 := self.expect(':'))
            and
            (b := self.body())
        ):
            return StructDef ( name = a . string , defs = b )
        self._reset(mark)
        return None

    @memoize
    def var_def(self) -> Optional[Any]:
        # var_def: type NAME default? var_def_more*
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (c := self.default(),)
            and
            (d := self._loop0_5(),)
        ):
            return VarDef ( type = a , ** get_var_def_list ( b . string , c , d ) )
        self._reset(mark)
        return None

    @memoize
    def var_def_more(self) -> Optional[Any]:
        # var_def_more: ',' NAME default?
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (a := self.name())
            and
            (b := self.default(),)
        ):
            return ( a . string , b if b else None )
        self._reset(mark)
        return None

    @memoize
    def arg_def(self) -> Optional[Any]:
        # arg_def: type NAME default? | '...'
        mark = self._mark()
        if (
            (a := self.type())
            and
            (b := self.name())
            and
            (c := self.default(),)
        ):
            return ArgDef ( type = a , name = b . string , default = c if c else None )
        self._reset(mark)
        if (
            (literal := self.expect('...'))
        ):
            return More ( )
        self._reset(mark)
        return None

    @memoize
    def default(self) -> Optional[Any]:
        # default: '=' expression
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (a := self.expression())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def assign(self) -> Optional[Any]:
        # assign: assign_exp '=' expression
        mark = self._mark()
        if (
            (a := self.assign_exp())
            and
            (literal := self.expect('='))
            and
            (c := self.expression())
        ):
            return Assign ( targets = [a] , value = c )
        self._reset(mark)
        return None

    @memoize
    def assign_more(self) -> Optional[Any]:
        # assign_more: '=' expression
        mark = self._mark()
        if (
            (literal := self.expect('='))
            and
            (a := self.expression())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def assign_exp(self) -> Optional[Any]:
        # assign_exp: '*'+ assign_exp | t_primary '[' expression ']' !t_lookahead | t_primary '.' NAME !t_lookahead | call !t_lookahead | NAME
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (a := self._loop1_6())
            and
            (b := self.assign_exp())
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return UnpackRef ( exp = b , level = len ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.expression())
            and
            (literal_1 := self.expect(']'))
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return Subscript ( value = a , slice = b , mode = Store ( ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return Attribute ( value = a , attr = b . string , mode = Store ( ) )
        self._reset(mark)
        if (
            (call := self.call())
            and
            self.negative_lookahead(self.t_lookahead, )
        ):
            return call
        self._reset(mark)
        if (
            (a := self.name())
        ):
            return Name ( id = a . string , mode = Store ( ) )
        self._reset(mark)
        return None

    @memoize_left_rec
    def t_primary(self) -> Optional[Any]:
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' expression ']' &t_lookahead | NAME &t_lookahead
        mark = self._mark()
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Attribute ( value = a , attr = b . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (a := self.t_primary())
            and
            (literal := self.expect('['))
            and
            (b := self.expression())
            and
            (literal_1 := self.expect(']'))
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Subscript ( value = a , slice = b , mode = Load ( ) )
        self._reset(mark)
        if (
            (a := self.name())
            and
            self.positive_lookahead(self.t_lookahead, )
        ):
            return Name ( id = a . string , mode = Load ( ) )
        self._reset(mark)
        return None

    @memoize
    def t_lookahead(self) -> Optional[Any]:
        # t_lookahead: '(' | '[' | '.'
        mark = self._mark()
        if (
            (literal := self.expect('('))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('['))
        ):
            return literal
        self._reset(mark)
        if (
            (literal := self.expect('.'))
        ):
            return literal
        self._reset(mark)
        return None

    @memoize
    def expression(self) -> Optional[Any]:
        # expression: or_exp
        mark = self._mark()
        if (
            (or_exp := self.or_exp())
        ):
            return or_exp
        self._reset(mark)
        return None

    @memoize
    def or_exp(self) -> Optional[Any]:
        # or_exp: and_exp (('or' and_exp))+ | and_exp
        mark = self._mark()
        if (
            (a := self.and_exp())
            and
            (b := self._loop1_7())
        ):
            return BoolOp ( op = Or ( ) , values = [a] + [i [1] for i in b] )
        self._reset(mark)
        if (
            (and_exp := self.and_exp())
        ):
            return and_exp
        self._reset(mark)
        return None

    @memoize
    def and_exp(self) -> Optional[Any]:
        # and_exp: bitor_exp (('and' bitor_exp))+ | bitor_exp
        mark = self._mark()
        if (
            (a := self.bitor_exp())
            and
            (b := self._loop1_8())
        ):
            return BoolOp ( op = And ( ) , values = [a] + [i [1] for i in b] )
        self._reset(mark)
        if (
            (bitor_exp := self.bitor_exp())
        ):
            return bitor_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitor_exp(self) -> Optional[Any]:
        # bitor_exp: bitor_exp '|' bitxor_exp | bitxor_exp
        mark = self._mark()
        if (
            (a := self.bitor_exp())
            and
            (literal := self.expect('|'))
            and
            (b := self.bitxor_exp())
        ):
            return BinOp ( left = a , op = BitOr ( ) , right = b )
        self._reset(mark)
        if (
            (bitxor_exp := self.bitxor_exp())
        ):
            return bitxor_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitxor_exp(self) -> Optional[Any]:
        # bitxor_exp: bitxor_exp '^' bitand_exp | bitand_exp
        mark = self._mark()
        if (
            (a := self.bitxor_exp())
            and
            (literal := self.expect('^'))
            and
            (b := self.bitand_exp())
        ):
            return BinOp ( left = a , op = BitXor ( ) , right = b )
        self._reset(mark)
        if (
            (bitand_exp := self.bitand_exp())
        ):
            return bitand_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitand_exp(self) -> Optional[Any]:
        # bitand_exp: bitand_exp '&' compare_exp | compare_exp
        mark = self._mark()
        if (
            (a := self.bitand_exp())
            and
            (literal := self.expect('&'))
            and
            (b := self.compare_exp())
        ):
            return BinOp ( left = a , op = BitAnd ( ) , right = b )
        self._reset(mark)
        if (
            (compare_exp := self.compare_exp())
        ):
            return compare_exp
        self._reset(mark)
        return None

    @memoize
    def compare_exp(self) -> Optional[Any]:
        # compare_exp: shift_exp compares | shift_exp
        mark = self._mark()
        if (
            (a := self.shift_exp())
            and
            (b := self.compares())
        ):
            return Compare ( left = a , ops = [i for i , j in b] , values = [j for i , j in b] )
        self._reset(mark)
        if (
            (shift_exp := self.shift_exp())
        ):
            return shift_exp
        self._reset(mark)
        return None

    @memoize
    def compares(self) -> Optional[Any]:
        # compares: compare+
        mark = self._mark()
        if (
            (_loop1_9 := self._loop1_9())
        ):
            return _loop1_9
        self._reset(mark)
        return None

    @memoize
    def compare(self) -> Optional[Any]:
        # compare: '<' shift_exp | '<=' shift_exp | '>' shift_exp | '>=' shift_exp | '==' shift_exp | '!=' shift_exp
        mark = self._mark()
        if (
            (literal := self.expect('<'))
            and
            (a := self.shift_exp())
        ):
            return ( Lt ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('<='))
            and
            (a := self.shift_exp())
        ):
            return ( Leq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('>'))
            and
            (a := self.shift_exp())
        ):
            return ( Gt ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('>='))
            and
            (a := self.shift_exp())
        ):
            return ( Geq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('=='))
            and
            (a := self.shift_exp())
        ):
            return ( Eq ( ) , a )
        self._reset(mark)
        if (
            (literal := self.expect('!='))
            and
            (a := self.shift_exp())
        ):
            return ( Neq ( ) , a )
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_exp(self) -> Optional[Any]:
        # shift_exp: shift_exp '<<' add_exp | shift_exp '>>' add_exp | add_exp
        mark = self._mark()
        if (
            (a := self.shift_exp())
            and
            (literal := self.expect('<<'))
            and
            (b := self.add_exp())
        ):
            return BinOp ( left = a , op = RShift ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.shift_exp())
            and
            (literal := self.expect('>>'))
            and
            (b := self.add_exp())
        ):
            return BinOp ( left = a , op = LShift ( ) , right = b )
        self._reset(mark)
        if (
            (add_exp := self.add_exp())
        ):
            return add_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def add_exp(self) -> Optional[Any]:
        # add_exp: add_exp '+' mul_exp | add_exp '-' mul_exp | mul_exp
        mark = self._mark()
        if (
            (a := self.add_exp())
            and
            (literal := self.expect('+'))
            and
            (b := self.mul_exp())
        ):
            return BinOp ( left = a , op = Add ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.add_exp())
            and
            (literal := self.expect('-'))
            and
            (b := self.mul_exp())
        ):
            return BinOp ( left = a , op = Sub ( ) , right = b )
        self._reset(mark)
        if (
            (mul_exp := self.mul_exp())
        ):
            return mul_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def mul_exp(self) -> Optional[Any]:
        # mul_exp: mul_exp '*' prefix_exp | mul_exp '/' prefix_exp | mul_exp '%' prefix_exp | prefix_exp
        mark = self._mark()
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('*'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Mul ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('/'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Div ( ) , right = b )
        self._reset(mark)
        if (
            (a := self.mul_exp())
            and
            (literal := self.expect('%'))
            and
            (b := self.prefix_exp())
        ):
            return BinOp ( left = a , op = Mod ( ) , right = b )
        self._reset(mark)
        if (
            (prefix_exp := self.prefix_exp())
        ):
            return prefix_exp
        self._reset(mark)
        return None

    @memoize
    def prefix_exp(self) -> Optional[Any]:
        # prefix_exp: '&' postfix_exp | '*'+ postfix_exp | postfix_exp
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (literal := self.expect('&'))
            and
            (a := self.postfix_exp())
        ):
            return Address ( exp = a )
        self._reset(mark)
        if (
            (a := self._loop1_10())
            and
            (b := self.postfix_exp())
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return UnpackRef ( exp = b , level = len ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (postfix_exp := self.postfix_exp())
        ):
            return postfix_exp
        self._reset(mark)
        return None

    @memoize_left_rec
    def postfix_exp(self) -> Optional[Any]:
        # postfix_exp: postfix_exp '[' expression ']' | call | postfix_exp '.' NAME | primary_exp
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (a := self.postfix_exp())
            and
            (literal := self.expect('['))
            and
            (b := self.expression())
            and
            (literal_1 := self.expect(']'))
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return Subscript ( value = a , slice = b , mode = Load ( ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if (
            (call := self.call())
        ):
            return call
        self._reset(mark)
        if (
            (a := self.postfix_exp())
            and
            (literal := self.expect('.'))
            and
            (b := self.name())
        ):
            return Attribute ( value = a , attr = b . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (primary_exp := self.primary_exp())
        ):
            return primary_exp
        self._reset(mark)
        return None

    @memoize
    def call(self) -> Optional[Any]:
        # call: NAME '(' arg_exp_list? ')'
        mark = self._mark()
        tok = self._tokenizer.peek()
        start_lineno, start_col_offset = tok.start
        if (
            (a := self.name())
            and
            (literal := self.expect('('))
            and
            (b := self.arg_exp_list(),)
            and
            (literal_1 := self.expect(')'))
        ):
            tok = self._tokenizer.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end
            return Call ( func = a . string , args = b if b else [] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @memoize
    def arg_def_list(self) -> Optional[Any]:
        # arg_def_list: arg_def arg_def_more*
        mark = self._mark()
        if (
            (a := self.arg_def())
            and
            (b := self._loop0_11(),)
        ):
            return [a] + b if b else [a]
        self._reset(mark)
        return None

    @memoize
    def arg_def_more(self) -> Optional[Any]:
        # arg_def_more: ',' arg_def
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (a := self.arg_def())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def arg_exp_list(self) -> Optional[Any]:
        # arg_exp_list: expression arg_exp_more*
        mark = self._mark()
        if (
            (a := self.expression())
            and
            (b := self._loop0_12(),)
        ):
            return [a] + b if b else [a]
        self._reset(mark)
        return None

    @memoize
    def arg_exp_more(self) -> Optional[Any]:
        # arg_exp_more: ',' expression
        mark = self._mark()
        if (
            (literal := self.expect(','))
            and
            (a := self.expression())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def primary_exp(self) -> Optional[Any]:
        # primary_exp: NAME | STRING | NUMBER | '(' expression ')'
        mark = self._mark()
        if (
            (name := self.name())
        ):
            return Name ( id = name . string , mode = Load ( ) )
        self._reset(mark)
        if (
            (string := self.string())
        ):
            return String ( value = string . string [1 : - 1] )
        self._reset(mark)
        if (
            (number := self.number())
        ):
            return Num ( value = number . string )
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (a := self.expression())
            and
            (literal_1 := self.expect(')'))
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: sentence
        mark = self._mark()
        children = []
        while (
            (sentence := self.sentence())
        ):
            children.append(sentence)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_2(self) -> Optional[Any]:
        # _loop1_2: define
        mark = self._mark()
        children = []
        while (
            (define := self.define())
        ):
            children.append(define)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_3(self) -> Optional[Any]:
        # _loop1_3: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_4(self) -> Optional[Any]:
        # _loop1_4: array_dimen
        mark = self._mark()
        children = []
        while (
            (array_dimen := self.array_dimen())
        ):
            children.append(array_dimen)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_5(self) -> Optional[Any]:
        # _loop0_5: var_def_more
        mark = self._mark()
        children = []
        while (
            (var_def_more := self.var_def_more())
        ):
            children.append(var_def_more)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_6(self) -> Optional[Any]:
        # _loop1_6: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_7(self) -> Optional[Any]:
        # _loop1_7: ('or' and_exp)
        mark = self._mark()
        children = []
        while (
            (_tmp_13 := self._tmp_13())
        ):
            children.append(_tmp_13)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_8(self) -> Optional[Any]:
        # _loop1_8: ('and' bitor_exp)
        mark = self._mark()
        children = []
        while (
            (_tmp_14 := self._tmp_14())
        ):
            children.append(_tmp_14)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_9(self) -> Optional[Any]:
        # _loop1_9: compare
        mark = self._mark()
        children = []
        while (
            (compare := self.compare())
        ):
            children.append(compare)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_10(self) -> Optional[Any]:
        # _loop1_10: '*'
        mark = self._mark()
        children = []
        while (
            (literal := self.expect('*'))
        ):
            children.append(literal)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_11(self) -> Optional[Any]:
        # _loop0_11: arg_def_more
        mark = self._mark()
        children = []
        while (
            (arg_def_more := self.arg_def_more())
        ):
            children.append(arg_def_more)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_12(self) -> Optional[Any]:
        # _loop0_12: arg_exp_more
        mark = self._mark()
        children = []
        while (
            (arg_exp_more := self.arg_exp_more())
        ):
            children.append(arg_exp_more)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _tmp_13(self) -> Optional[Any]:
        # _tmp_13: 'or' and_exp
        mark = self._mark()
        if (
            (literal := self.expect('or'))
            and
            (and_exp := self.and_exp())
        ):
            return [literal, and_exp]
        self._reset(mark)
        return None

    @memoize
    def _tmp_14(self) -> Optional[Any]:
        # _tmp_14: 'and' bitor_exp
        mark = self._mark()
        if (
            (literal := self.expect('and'))
            and
            (bitor_exp := self.bitor_exp())
        ):
            return [literal, bitor_exp]
        self._reset(mark)
        return None

    KEYWORDS = ('elif', 'while', 'char', 'or', 'else', 'struct', 'and', 'extern', 'return', 'pass', 'if', 'void', 'int')
    SOFT_KEYWORDS = ()


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
