# 简介
`c--3`是使用python编写的一款编程语言,它与`c--0.x``c--1.x``c--2.x`不同的是,它采用了别的运行方式,虽然没什么用而且会使它更慢
# 语法
与python语法类似
# 特性
## 捕获语法错误
由于运行机制的特殊,`c--3`可以完成许多别的编程语言无法做到的事情
```
try:
    if a
        a=1
except:
    print('Exception')
```
这段代码的2-3行有语法错误，像python这样的语言会抛出该错误而无视`try-except`语句，但`c--3`会捕捉这样的语法错误，因此这段代码最终会执行第5行的内容
- 注意，我并没有加入对语法错误时的恢复处理，因此一个语法错误可能会导致一连串的语法错误，甚至会导致`try-except`语句无法正常解析
## 添加新的语法
每个运行环境都内置一个Parser变量，通过这个变量可以为`c--3`添加新语法
```
def f1(parser):
    parser.expect('f')
    print('Hello,World')
Parser.sentences['f']=f1
f
```
输出
```
Hello,World
```
上面是一个简单的例子，在遇到一个标识符时，会到`Parser.sentences`中寻找对应的处理函数，找到后会执行改函数的内容，如果该函数是用户自定义的`SyntaxTree`对象，会先解析函数再运行，同时会传入对应的`parser`变量，如果想添加表达式，可以往`Parser.priority`中添加函数
# 运行机制
## 概况
`c--3`运行的时侯通过语法分析得到语法树后,就开始运行,不生成字节码,以语法树作为字节码运行。可以看成将原先生成字节码的步骤改成了直接运行
## 词法分析
`c--3`的词法分析无太大差别，唯一不同的是它多了`startlineno`和`endlineno`两个变量，这两个变量指的是词法分析时代码的解析的起始位置和终止位置，具体原因会在[后面](####`Unkown`语法树)讲到
## 语法分析
由于特殊需要，`c--3`的语法分析并没有使用`pegen`生成，而是手动编写，语法跟`python`差不多
### 语法树
在`c--3`中，语法树似乎发挥了很大的作用
#### `Unkown`语法树
在遇到某些语句比如`if`,`while`,`def`时，我们会跳过相应的代码块，并用`Unkown`语法树代替。它保存了代码块的信息，在执行的时侯会根据这些信息，回到原来的位置解析，此时`Lexer`的`startlineno`和`endlineno`就发挥了用处
#### `break`,`contiune`,`return`
由于特殊的机制，这些跳转动作抛出对应的异常来达到目标
`BreadException`和`ContinueException`可以被`while`语句捕捉，并据此执行相应的操作
`ReturnException`可以被`SyntaxTree.call`捕捉
如果它们不在他们该在的位置，这些异常将会被`_compile`捕捉并输出错误信息
### `justrun`
`c--3`语法分析时，有两种情况，第一种是编译出一个语法树就运行，这需要`justrun=True`,另一种是全部编译完再运行,这需要`justrun=False`